export const sections = [
  {
    id: "cs",
    title: "CS",
    items: [
      {
        q: "프로세스 vs 스레드",
        points: [
          "프로세스: 실행 중인 프로그램 하나\n(메모리 독립적)",
          "스레드: 프로세스 내부에서 실행되는 CPU 실행 단위\n(메모리 공유 -> 생성과 전환의 비용 적음)",
        ],
        note: "하나의 프로세스 안에서 여러 작업을 병렬로 처리하기 위해 스레드를 사용함",
      },
      {
        q: "HTTP vs HTTPS",
        points: [
          "HTTP: 데이터가 암호화가 안된 상태로 전송되어 중간자 공격에 취약함",
          "HTTPS: TLS로 데이터 암호화\n(TLS는 안전한 통신을 위한 암호화 프로토콜)",
        ],
        note: "HTTPS는 TLS를 통해 서버를 인증하고 통신 내용을 암호화하여 중간자 공격으로부터 데이터의 기밀성과 무결성을 보장",
      },
      {
        q: "REST API vs RESTful API",
        points: [
          "REST API: REST 방식을 쓰는 API\n(URL과 HTTP 메서드 사용)",
          "RESTful API: REST 방식을 잘 지킨 API (자원중심설계, HTTP 메서드 의미 준수, 무상태성)",
        ],
        note: "POST /getUser 같은 경우도 REST API라고 부르긴 하지만, 자원 중심 설계와 HTTP 메서드 의미를 지키지 않아 RESTful하다고 보긴 어려움",
      },
      {
        q: "HTTP 메서드 정리",
        points: [
          "GET: 조회, 여러 번 요청해도 결과가 달라지지 않음, 서버 상태 변경 X, 안전한 메서드",
          "POST: 생성, 처리 요청, 요청할 때마다 새로운 결과가 생길 수 있음, 서버 상태 변경 O, 조회용으로 사용 X",
          "PUT: 자원 전체 교체, 같은 요청을 다시 보내도 결과가 동일하게 유지됨",
          "PATCH: 자원 일부 수정, 수정한 부분만 변경됨",
          "DELETE: 자원 삭제, 한 번 삭제해도, 다시 요청하면 삭제된 상태 그대로 유지됨",
        ],
      },
    ],
  },
  {
    id: "js, ts",
    title: "JavaScript & TypeScript",
    items: [
      {
        q: "var, let, const",
        points: [
          "var: 함수 스코프, 중복 선언 가능, 호이스팅 발생",
          "let: 블록 스코프, 중복 선언 불가, 호이스팅 발생하지만 선언 전 사용 불가",
          "const: 블록 스코프, 중복 선언 불가, 재할당 불가, 호이스팅 발생하지만 선언 전 사용 불가",
        ],
        note: "const로 선언된 객체나 배열은 내부 값 변경 가능하지만, 재할당은 불가능!",
      },
      {
        q: "싱글 스레드와 이벤트 루프",
        points: [
          "Node.js는 싱글 스레드 기반으로 동작함 (하나의 콜 스택)",
          "하지만 이벤트 루프를 통해 비동기 작업을 처리하여 여러 요청을 효율적으로 처리함",
          "비동기 작업(setTimeout, 파일 읽기 등)은 바로 실행되지 않고 콜백 큐에 대기함",
        ],
        note: "이벤트 루프가 콜 스택이 비어 있는지 확인하고, 비어 있으면 콜백 큐의 작업을 콜 스택으로 옮겨 실행함",
      },
      {
        q: "콜 스택 / 콜백 큐 / 이벤트 루프",
        points: [
          "콜 스택: 현재 실행 중인 함수가 쌓이는 공간 (LIFO 구조)",
          "콜백 큐: 비동기 작업이 완료된 후 실행을 기다리는 공간 (대기실 역할)",
          "이벤트 루프: 콜 스택이 비어 있는지 계속 확인하고, 비어 있으면 콜백 큐의 작업을 콜 스택으로 이동시킴",
        ],
        note: "자바스크립트는 싱글 스레드지만, 이벤트 루프 덕분에 비동기 처리가 가능함",
      },
      {
        q: "클로저 (Closure)",
        points: [
          "내부 함수가 외부 함수의 변수(상태나 값 등)를 기억해서, 외부 함수 실행이 끝나도 계속 접근할 수 있게 해 주는 것",
        ],
        note: "상태를 기억하거나, 은닉(캡슐화)하고 싶을 때 유용함",
      },
    ],
  },

  {
    id: "React",
    title: "React",
    items: [
      {
        q: "React를 사용하는 이유",
        points: [
          "React는 컴포넌트 기반 구조로 재사용성이 높음",
          "Virtual DOM을 사용해 변경된 부분만 렌더링하여 성능이\n좋음",
          "상태 변화에 따라 UI가 자동으로 업데이트되어 상태 관리가 쉬움",
        ],
        note: "Virtual DOM은 실제 DOM 수정 전에 변경점만 계산해서 최소한으로 업데이트",
      },
      {
        q: "State vs Props",
        points: [
          "State: 컴포넌트 내부에서 관리\n값 변경 가능 (setState)\n변경 시 리렌더링 발생",
          "Props: 부모 → 자식 전달 데이터\n읽기 전용 (자식이 수정 X)\n변경되면 자식 리렌더링",
        ],
        note: "State는 내가 관리하는 값, Props는 부모가 준 값",
      },
      {
        q: "useState / useEffect / useRef",
        points: [
          "useState: 컴포넌트의 상태 관리\n상태 변경 시 리렌더링",
          "useEffect: 렌더링 이후 실행되는 사이드 이펙트 처리\n예: API 호출, 이벤트 등록/해제, 타이머",
          "useRef: 변경 가능한 참조값 관리, 값 변경해도 리렌더링 X",
        ],
        note: "useState는 값, useEffect는 동작,useRef는 DOM 접근이나 이전 값 저장에 유용함",
      },
      {
        q: "리렌더링 발생 조건",
        points: ["State 변경 시", "Props 변경 시", "부모 컴포넌트 리렌더링 시"],
        note: "같은 값으로 setState → 리렌더링 안 될 수도 있음\n리렌더링 ≠ DOM 전체 다시 그림",
      },
    ],
  },

  {
    id: "Node.js",
    title: "Node.js",
    items: [
      {
        q: "Node.js란?",
        points: [
          "Chrome V8 JavaScript 엔진 기반의 자바스크립트 런타임으로 브라우저 밖에서도 자바스크립트를 실행할 수 있게 해줌",
        ],
        note: "서버도 아니고 프레임워크도 아님\n서버를 만들 수 있는 실행 환경이고, Express 같은 프레임워크를 사용해 서버 개발 가능",
      },
      {
        q: "Node.js는 논블로킹/비동기 방식 사용",
        points: [
          "논블로킹: 작업을 요청해도 제어권을 뺏기지 않고 즉시 다음 작업을 수행함",
          "비동기: 작업 완료를 기다리지 않고, 완료 시점에 콜백/Promise로 결과를 처리함",
        ],
        note: "I/O 작업을 논블로킹·비동기 방식으로 처리해서 하나의 스레드로도 많은 요청을 효율적으로 처리할 수 있음",
      },
      {
        q: "Node.js 처리 방식",
        points: [
          "싱글 스레드 기반이지만 이벤트 루프를 통해 비동기 작업을 처리하여 여러 요청을 효율적으로 처리함",
        ],
        note: "CPU 집약적인 작업에는 멀티스레드 언어가 더 적합하며, Node.js는 I/O 중심 작업에 강함",
      },
    ],
  },
];
